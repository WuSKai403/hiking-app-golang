package services

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/WuSKai403/hiking-app-golang/configs"
	"github.com/WuSKai403/hiking-app-golang/internal/models"
	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

var genaiClient *genai.GenerativeModel

func InitGenAI() {
	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(configs.AppConfig.GeminiAPIKey))
	if err != nil {
		log.Fatalf("Failed to create GenAI client: %v", err)
	}

	// Use a model that supports tooling and is available in the v1beta API.
	// Models like 'gemini-1.5-pro-latest' seem to require a newer API version than the SDK defaults to.
	// 'gemini-pro' is a stable and widely available choice.
	genaiClient = client.GenerativeModel("gemini-2.5-pro")

	// Define the exact JSON schema we want the model to output.
	schema := &genai.Schema{
		Type: genai.TypeObject,
		Properties: map[string]*genai.Schema{
			"safety_score": {
				Type:        genai.TypeNumber,
				Description: "安全評分 (1: 極危險, 5: 非常安全)。",
			},
			"recommendation": {
				Type:        genai.TypeString,
				Description: "簡潔的結論 (例如：建議攜帶雨具, 今日不宜登頂)。",
			},
			"reasoning": {
				Type:        genai.TypeString,
				Description: "AI 綜合當前天氣和近期評論判斷的詳細理由。",
			},
		},
		Required: []string{"safety_score", "recommendation", "reasoning"},
	}

	// Wrap the schema in a FunctionDeclaration to enforce structured output.
	// This forces the model to call this "function" with the specified parameters.
	genaiClient.Tools = []*genai.Tool{
		{
			FunctionDeclarations: []*genai.FunctionDeclaration{
				{
					Name:        "get_hiking_recommendation",
					Description: "根據提供的數據提供結構化的健行建議。",
					Parameters:  schema,
				},
			},
		},
	}
}

func buildPrompt(request models.RecommendationRequest, weatherData string, reviewData string) string {
	// The prompt is simplified as the schema now carries the structural requirements.
	return fmt.Sprintf(`
    你是台灣專業登山顧問 AI。請根據以下即時數據和使用者情境，評估健行路徑的安全性，並呼叫 get_hiking_recommendation 函式來提供你的分析結果。

    使用者請求：
    - 路徑 ID: %s
    - 額外描述: %s

    即時氣象資料:
    ---
    %s
    ---

    近期路徑評論:
    ---
    %s
    ---
    `, request.TrailID, request.UserPathDesc, weatherData, reviewData)
}

func GetAiRecommendation(request models.RecommendationRequest, weatherData string, reviewData string) (*models.RecommendationResponse, error) {
	ctx := context.Background()
	prompt := buildPrompt(request, weatherData, reviewData)

	resp, err := genaiClient.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate content: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no content generated by the API")
	}

	// Extract the function call from the response part.
	part := resp.Candidates[0].Content.Parts[0]
	fc, ok := part.(genai.FunctionCall)
	if !ok {
		return nil, fmt.Errorf("unexpected response format from API, expected a function call, got: %T", part)
	}

	// The arguments of the function call are the JSON data we need.
	jsonData, err := json.Marshal(fc.Args)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal function call args: %w", err)
	}

	var recommendation models.RecommendationResponse
	if err := json.Unmarshal(jsonData, &recommendation); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON response from function call: %w", err)
	}

	recommendation.DataSource = "Gemini Real-time"
	return &recommendation, nil
}
